---
phase: 02-enhanced-task-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/database/schema.js
  - server/routes/taskConfirmation.js
  - server/index.js
autonomous: true

must_haves:
  truths:
    - "Worker can submit image and note from confirmation page"
    - "Image file saved to /uploads directory with unique filename"
    - "Image path and note stored in database"
    - "Upload endpoint accepts multipart/form-data"
    - "Manager receives real-time update when completion data submitted"
  artifacts:
    - path: "server/database/schema.js"
      provides: "task_attachments table and completion_note column"
      contains: "CREATE TABLE IF NOT EXISTS task_attachments"
    - path: "server/routes/taskConfirmation.js"
      provides: "POST /:token/complete endpoint with multer"
      exports: ["router"]
    - path: "uploads/"
      provides: "Image storage directory"
      min_files: 0
  key_links:
    - from: "server/routes/taskConfirmation.js"
      to: "multer.diskStorage"
      via: "file upload middleware"
      pattern: "multer\\.diskStorage"
    - from: "server/routes/taskConfirmation.js"
      to: "db.prepare"
      via: "database insert"
      pattern: "INSERT INTO task_attachments"
    - from: "server/routes/taskConfirmation.js"
      to: "io.emit"
      via: "real-time broadcast"
      pattern: "io\\.emit\\('task:updated'"
---

<objective>
Create backend infrastructure for image uploads and notes on task completion.

Purpose: Workers need ability to attach evidence (photos) and context (notes) when completing tasks. This establishes the storage and API layer.

Output: Database schema for attachments, file upload endpoint with multer, real-time broadcasts for completion data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-enhanced-task-completion/02-RESEARCH.md

# Prior phase summaries
@.planning/phases/01-real-time-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-real-time-infrastructure/01-02-SUMMARY.md

# Codebase context
@server/database/schema.js
@server/routes/taskConfirmation.js
@server/index.js
</context>

<tasks>

<task type="auto">
  <name>Create database schema for task attachments and completion notes</name>
  <files>
    server/database/schema.js
  </files>
  <action>
Add task_attachments table and completion_note column to tasks table.

**1. Create task_attachments table:**
Use separate table (not columns in tasks table) for scalability - allows unlimited images per task, easier querying, cleaner schema.

```sql
CREATE TABLE IF NOT EXISTS task_attachments (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  task_id INTEGER NOT NULL,
  file_path TEXT NOT NULL,
  file_type TEXT CHECK(file_type IN ('image', 'note')) NOT NULL,
  uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
)
```

Place this table creation after task_confirmations table (around line 190).

**2. Add completion_note column to tasks table:**
Use migration pattern (try-catch ALTER TABLE) matching existing migrations (lines 62-80).

```javascript
try {
  db.exec(`ALTER TABLE tasks ADD COLUMN completion_note TEXT`);
} catch (e) {
  // Column already exists, ignore error
}
```

Add this migration after acknowledged_at migration (around line 81).

**Why separate table instead of JSON column:**
- Easier to query images per task
- Supports foreign key constraints
- Cleaner for multiple images
- Follows normalized design (RESEARCH.md recommendation)

**Why file paths not BLOBs:**
- Keep database compact (RESEARCH.md Pitfall 3)
- Enable filesystem-based backups
- Better performance for large files
  </action>
  <verify>
Run server and check logs for "Database tables initialized successfully".
Check database file with: `sqlite3 maintenance.db ".schema task_attachments"`
  </verify>
  <done>
- task_attachments table exists with id, task_id, file_path, file_type, uploaded_at columns
- tasks table has completion_note TEXT column
- Server starts without errors
  </done>
</task>

<task type="auto">
  <name>Create file upload endpoint with multer for task completion</name>
  <files>
    server/routes/taskConfirmation.js
    server/index.js
  </files>
  <action>
Add POST /:token/complete endpoint that accepts multipart form data with image and note.

**1. Configure multer at top of taskConfirmation.js:**

```javascript
const multer = require('multer');
const crypto = require('crypto');
const path = require('path');
const fs = require('fs');

// Ensure uploads directory exists
const uploadsDir = path.join(__dirname, '..', '..', 'uploads');
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

// Configure multer with secure filename generation
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadsDir);
  },
  filename: (req, file, cb) => {
    // Generate unique filename with crypto (RESEARCH.md Pattern 1)
    const uniqueName = crypto.randomBytes(16).toString('hex');
    const ext = path.extname(file.originalname);
    cb(null, uniqueName + ext);
  }
});

const upload = multer({
  storage: storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit (RESEARCH.md recommendation)
  fileFilter: (req, file, cb) => {
    // Only allow images (RESEARCH.md security pattern)
    const allowedTypes = ['image/jpeg', 'image/png', 'image/jpg'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('רק קבצי JPG ו-PNG מותרים'));
    }
  }
});
```

**2. Add POST /:token/complete route:**

Add this route AFTER existing GET /:token route (around line 40):

```javascript
// Complete task with image and note
router.post('/:token/complete', upload.single('image'), async (req, res) => {
  try {
    const { token } = req.params;
    const { taskId, note } = req.body;

    // Validate token
    const confirmation = db.prepare(`
      SELECT * FROM task_confirmations WHERE token = ?
    `).get(token);

    if (!confirmation) {
      return res.status(404).json({ error: 'קישור לא תקין' });
    }

    // Check if this task belongs to this token
    const taskIds = JSON.parse(confirmation.task_ids);
    if (!taskIds.includes(parseInt(taskId))) {
      return res.status(403).json({ error: 'משימה לא שייכת לקישור זה' });
    }

    // Save image if uploaded
    if (req.file) {
      const imagePath = `/uploads/${req.file.filename}`;
      db.prepare(`
        INSERT INTO task_attachments (task_id, file_path, file_type)
        VALUES (?, ?, 'image')
      `).run(taskId, imagePath);
    }

    // Save note if provided
    if (note && note.trim()) {
      db.prepare(`
        UPDATE tasks SET completion_note = ? WHERE id = ?
      `).run(note.trim(), taskId);
    }

    // Update task status to completed
    db.prepare(`
      UPDATE tasks SET status = 'completed', updated_at = CURRENT_TIMESTAMP
      WHERE id = ?
    `).run(taskId);

    // Fetch updated task with JOINs for real-time broadcast
    const updatedTask = db.prepare(`
      SELECT t.*, s.name as system_name, e.name as employee_name
      FROM tasks t
      LEFT JOIN systems s ON t.system_id = s.id
      LEFT JOIN employees e ON t.employee_id = e.id
      WHERE t.id = ?
    `).get(taskId);

    // Broadcast real-time update (Phase 1 pattern)
    if (io) {
      io.emit('task:updated', { task: updatedTask });
    }

    res.json({
      success: true,
      message: 'המשימה עודכנה בהצלחה',
      imagePath: req.file ? `/uploads/${req.file.filename}` : null
    });
  } catch (error) {
    console.error('Error completing task:', error);
    res.status(500).json({ error: 'שגיאה בשמירת הנתונים' });
  }
});
```

**3. Import io at top of file:**

Match dependency injection pattern from Phase 1 (01-02-SUMMARY.md):

```javascript
let io;
function setIo(ioInstance) {
  io = ioInstance;
}
```

Export setIo function at bottom:
```javascript
module.exports = { router, setIo };
```

**4. Update server/index.js to call setIo:**

After Socket.IO initialization (around line 60), add:

```javascript
const taskConfirmationRoutes = require('./routes/taskConfirmation');
taskConfirmationRoutes.setIo(io);
```

Update existing route registration (around line 68):
```javascript
app.use('/api/confirm', taskConfirmationRoutes.router);
```

**5. Ensure uploads directory served as static files:**

In server/index.js, verify express.static for /uploads exists (should be around line 75). If missing, add:

```javascript
app.use('/uploads', express.static(path.join(__dirname, '..', 'uploads')));
```

**Why single image not array:**
- TC-01 specifies "עובד יכול להעלות תמונה" (singular)
- Simpler UX for mobile workers
- Can extend to multiple in future phase

**Why validate token ownership:**
- Security: prevent task completion via guessed tokens
- Ensures worker can only complete their assigned tasks

**Critical security details (from RESEARCH.md):**
- Never use original filename (path traversal risk)
- Always use crypto.randomBytes for unique names
- Validate MIME types in fileFilter
- Set file size limits (5MB for images)
- Store paths not BLOBs in database
  </action>
  <verify>
1. Start server: `npm start`
2. Check uploads directory created: `ls uploads/`
3. Test endpoint with curl:
```bash
curl -X POST http://localhost:3002/api/confirm/[valid-token]/complete \
  -F "taskId=1" \
  -F "note=בדיקה" \
  -F "image=@test-image.jpg"
```
Should return: `{ "success": true, "message": "המשימה עודכנה בהצלחה", "imagePath": "/uploads/..." }`
4. Check file created in uploads/
5. Check database: `sqlite3 maintenance.db "SELECT * FROM task_attachments"`
  </verify>
  <done>
- POST /:token/complete endpoint exists and accepts multipart form data
- Multer configured with secure filename generation (crypto.randomBytes)
- Image files saved to /uploads directory with unique names
- File paths saved to task_attachments table
- Notes saved to tasks.completion_note column
- Task status updated to 'completed'
- Socket.IO broadcasts task:updated event after completion
- Endpoint validates token ownership before allowing completion
  </done>
</task>

</tasks>

<verification>

**Database Schema:**
1. Run: `sqlite3 c:\dev\projects\claude\ projects\eden\ claude\maintenance.db ".schema task_attachments"`
2. Verify table exists with correct columns (id, task_id, file_path, file_type, uploaded_at)
3. Run: `sqlite3 c:\dev\projects\claude\ projects\eden\ claude\maintenance.db "PRAGMA table_info(tasks)"`
4. Verify completion_note column exists

**Upload Endpoint:**
1. Server starts without errors on port 3002
2. uploads/ directory exists in project root
3. POST request with image returns success JSON
4. Image file appears in uploads/ with unique hex name
5. Database record in task_attachments with correct path
6. Console logs "Client received task:updated" (if client connected from Phase 1)

**Security:**
1. Verify multer rejects non-image files (test with .txt file)
2. Verify file size limit (test with >5MB image)
3. Verify token validation (test with invalid token)
4. Verify filenames are random hex strings (not original names)

</verification>

<success_criteria>

**Testable Outcomes:**
1. Database has task_attachments table and tasks.completion_note column
2. POST /api/confirm/:token/complete accepts multipart form data
3. Image uploaded from mobile/desktop saves to /uploads with unique filename
4. Image path stored in task_attachments table as TEXT
5. Note text stored in tasks.completion_note column
6. Task status updates to 'completed' after submission
7. Socket.IO broadcasts task:updated event with full task object
8. Endpoint rejects invalid tokens, non-image files, and oversized files
9. Multiple images for same task create multiple task_attachments records
10. Server logs show successful file saves and database inserts

</success_criteria>

<output>
After completion, create `.planning/phases/02-enhanced-task-completion/02-01-SUMMARY.md` following the summary template.

Include:
- Database schema changes (table + column)
- Multer configuration details
- Security validations implemented
- Real-time broadcast verification
- Any issues encountered (file permissions, path handling on Windows)
</output>
