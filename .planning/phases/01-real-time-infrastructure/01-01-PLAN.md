---
phase: 01-real-time-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/index.js
  - server/routes/tasks.js
  - server/routes/taskConfirmation.js
  - package.json
autonomous: true

must_haves:
  truths:
    - "Server accepts WebSocket connections from clients"
    - "When task status changes via API, all connected clients receive update event"
    - "Task completion from confirmation page broadcasts to manager interface"
  artifacts:
    - path: "server/index.js"
      provides: "Socket.IO server initialization and connection handling"
      min_lines: 10
      exports: ["io"]
    - path: "server/routes/tasks.js"
      provides: "Task update broadcasting"
      contains: "io.emit"
    - path: "server/routes/taskConfirmation.js"
      provides: "Task completion broadcasting"
      contains: "io.emit"
  key_links:
    - from: "server/routes/tasks.js"
      to: "Socket.IO server"
      via: "io.emit on task update"
      pattern: "io\\.emit\\(['\"]task"
    - from: "server/routes/taskConfirmation.js"
      to: "Socket.IO server"
      via: "io.emit on task completion"
      pattern: "io\\.emit\\(['\"]task"
---

<objective>
Set up WebSocket infrastructure on the server side using Socket.IO, enabling real-time broadcasting of task updates to all connected clients.

Purpose: Create the foundation for real-time updates. When tasks change (status, completion, notes, images), the server will broadcast these changes to all connected manager interfaces immediately.

Output: Working WebSocket server integrated with Express, task routes emitting events on all mutations.
</objective>

<execution_context>
@c:\dev\projects\claude projects\eden claude\.claude\get-shit-done\workflows\execute-plan.md
@c:\dev\projects\claude projects\eden claude\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@c:\dev\projects\claude projects\eden claude\.planning\PROJECT.md
@c:\dev\projects\claude projects\eden claude\.planning\ROADMAP.md
@c:\dev\projects\claude projects\eden claude\.planning\STATE.md
@c:\dev\projects\claude projects\eden claude\.planning\phases\01-real-time-infrastructure\01-CONTEXT.md
@c:\dev\projects\claude projects\eden claude\.planning\codebase\STACK.md
@c:\dev\projects\claude projects\eden claude\.planning\codebase\ARCHITECTURE.md
@c:\dev\projects\claude projects\eden claude\server\index.js
@c:\dev\projects\claude projects\eden claude\server\routes\tasks.js
@c:\dev\projects\claude projects\eden claude\server\routes\taskConfirmation.js
</context>

<tasks>

<task type="auto">
  <name>Install Socket.IO and initialize WebSocket server</name>
  <files>
    package.json
    server/index.js
  </files>
  <action>
1. Install socket.io server package:
   ```bash
   npm install socket.io
   ```

2. Modify server/index.js to integrate Socket.IO with Express:
   - Import socket.io and create Server from http module
   - Wrap Express app with http.Server
   - Initialize Socket.IO with CORS configuration (allow all origins for now, matching existing Express CORS)
   - Add connection event handler that logs client connections/disconnections
   - Export io instance so routes can access it
   - Update app.listen to use http server instead of Express app directly

3. Pattern to follow:
   ```javascript
   const http = require('http');
   const { Server } = require('socket.io');

   const server = http.createServer(app);
   const io = new Server(server, {
     cors: {
       origin: "*",
       methods: ["GET", "POST"]
     }
   });

   io.on('connection', (socket) => {
     console.log('Client connected:', socket.id);
     socket.on('disconnect', () => {
       console.log('Client disconnected:', socket.id);
     });
   });

   module.exports.io = io; // Export for use in routes
   ```

4. Change server.listen call to use `server` instead of `app`

Why this approach: Socket.IO requires http.Server wrapper around Express. CORS must match existing permissive setup. Exporting io allows routes to broadcast without circular dependencies.
  </action>
  <verify>
1. Run `npm install` successfully completes
2. Start server with `npm run dev:server` - no errors, logs show server running
3. Check console logs show Socket.IO initialized (no errors about missing modules)
4. Server responds to HTTP requests as before (test http://localhost:3001/api/tasks)
  </verify>
  <done>
- socket.io package in package.json dependencies
- server/index.js creates http.Server wrapper
- Socket.IO server initialized with CORS
- Connection/disconnection handlers log to console
- io instance exported from server/index.js
- Server starts without errors
  </done>
</task>

<task type="auto">
  <name>Add task update broadcasting to API routes</name>
  <files>
    server/routes/tasks.js
    server/routes/taskConfirmation.js
  </files>
  <action>
1. In server/routes/tasks.js:
   - Import io from server/index.js (require('../index').io or pass via middleware)
   - Find all mutation endpoints: POST / (create), PUT /:id (update), DELETE /:id (delete)
   - After successful database operation, before sending response, emit event:
     ```javascript
     if (io) {
       io.emit('task:updated', { task: updatedTask });
     }
     ```
   - Use event names: 'task:created', 'task:updated', 'task:deleted'
   - Include full task object in event payload (with system/employee names if available)

2. In server/routes/taskConfirmation.js:
   - Import io from server/index.js
   - Find PUT /:token/task/:taskId endpoint (status update from confirmation page)
   - After successful status update, emit:
     ```javascript
     if (io) {
       io.emit('task:updated', { task: updatedTask });
     }
     ```
   - Find POST /:token/acknowledge endpoint
   - After acknowledging, emit event for each task in confirmation

3. Handle io being undefined gracefully (if routes loaded before server setup)

Why this approach: Broadcasting after successful DB operation ensures clients only see valid changes. Using consistent event names ('task:*') makes client-side listening easier. Full task object payload eliminates need for client to refetch.
  </action>
  <verify>
1. Start server, open browser console
2. Create task via API (POST /api/tasks) - check server logs show io.emit called
3. Update task status via API (PUT /api/tasks/:id) - check server logs show io.emit called
4. No runtime errors about io being undefined
5. All existing API functionality still works (creates/updates succeed)
  </verify>
  <done>
- server/routes/tasks.js imports io and emits events on create/update/delete
- server/routes/taskConfirmation.js imports io and emits events on task status changes
- Event names follow pattern: 'task:created', 'task:updated', 'task:deleted'
- Event payloads include full task objects
- Graceful handling if io is undefined
- All existing API endpoints continue to work correctly
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Server starts without errors: `npm run dev:server`
2. Socket.IO server running on same port as Express (3001)
3. Console logs show "Client connected" when browser opens (even without client implementation)
4. Task mutations (create/update/delete via existing UI) log io.emit calls
5. No breaking changes to existing functionality
</verification>

<success_criteria>
- Socket.IO server integrated with Express and running
- All task mutation endpoints broadcast events after successful operations
- Connection handlers log client connections and disconnections
- Existing API functionality unaffected
- Server logs show event emissions when tasks are modified
- Foundation ready for client-side WebSocket connection (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/01-real-time-infrastructure/01-01-SUMMARY.md`
</output>
