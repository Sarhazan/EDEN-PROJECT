---
phase: 01-real-time-infrastructure
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - client/package.json
  - client/src/context/AppContext.jsx
  - client/src/components/layout/Sidebar.jsx
autonomous: false

must_haves:
  truths:
    - "Manager sees connection status indicator in UI"
    - "When task updated (from any source), manager UI updates automatically without refresh"
    - "Connection remains stable during normal usage"
    - "Multiple tabs all receive and display updates simultaneously"
  artifacts:
    - path: "client/src/context/AppContext.jsx"
      provides: "Socket.IO client connection and event listeners"
      min_lines: 30
      contains: "socket.on"
    - path: "client/src/components/layout/Sidebar.jsx"
      provides: "Connection status indicator UI"
      contains: "connectionStatus"
  key_links:
    - from: "client/src/context/AppContext.jsx"
      to: "Socket.IO server"
      via: "io() connection initialization"
      pattern: "io\\(.*\\)"
    - from: "client/src/context/AppContext.jsx"
      to: "tasks state"
      via: "socket.on event updates state"
      pattern: "socket\\.on.*setTasks"
---

<objective>
Connect the React client to the WebSocket server and implement real-time task updates in the manager interface.

Purpose: Complete the real-time infrastructure. Manager will see all task changes immediately as they happen, with visible connection status. Multiple browser tabs will stay synchronized automatically.

Output: React client connected to WebSocket server, all task mutations reflected in UI instantly, connection status displayed to user.
</objective>

<execution_context>
@c:\dev\projects\claude projects\eden claude\.claude\get-shit-done\workflows\execute-plan.md
@c:\dev\projects\claude projects\eden claude\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@c:\dev\projects\claude projects\eden claude\.planning\PROJECT.md
@c:\dev\projects\claude projects\eden claude\.planning\ROADMAP.md
@c:\dev\projects\claude projects\eden claude\.planning\STATE.md
@c:\dev\projects\claude projects\eden claude\.planning\phases\01-real-time-infrastructure\01-CONTEXT.md
@c:\dev\projects\claude projects\eden claude\.planning\phases\01-real-time-infrastructure\01-01-SUMMARY.md
@c:\dev\projects\claude projects\eden claude\.planning\codebase\STACK.md
@c:\dev\projects\claude projects\eden claude\.planning\codebase\ARCHITECTURE.md
@c:\dev\projects\claude projects\eden claude\client\src\context\AppContext.jsx
@c:\dev\projects\claude projects\eden claude\client\src\components\layout\Sidebar.jsx
</context>

<tasks>

<task type="auto">
  <name>Install Socket.IO client and establish WebSocket connection</name>
  <files>
    client/package.json
    client/src/context/AppContext.jsx
  </files>
  <action>
1. Install socket.io-client package:
   ```bash
   cd client && npm install socket.io-client
   ```

2. In client/src/context/AppContext.jsx:
   - Import socket.io-client at top: `import { io } from 'socket.io-client';`
   - Add connectionStatus state: `const [connectionStatus, setConnectionStatus] = useState('disconnected');`
   - In AppProvider component, initialize socket connection in useEffect:
     ```javascript
     useEffect(() => {
       const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001';
       const socket = io(API_URL);

       socket.on('connect', () => {
         console.log('WebSocket connected');
         setConnectionStatus('connected');
       });

       socket.on('disconnect', () => {
         console.log('WebSocket disconnected');
         setConnectionStatus('disconnected');
       });

       socket.on('connect_error', (error) => {
         console.error('WebSocket connection error:', error);
         setConnectionStatus('error');
       });

       // Store socket in ref for cleanup
       socketRef.current = socket;

       return () => {
         socket.disconnect();
       };
     }, []);
     ```
   - Add useRef for socket: `const socketRef = useRef(null);`
   - Export connectionStatus in context value

3. Pattern: Connection happens once on mount, stays open for app lifetime. Cleanup on unmount prevents leaks.

Why this approach: Socket.IO client auto-reconnects by default. Connection status tracking lets us show user if they're offline. Using ref allows other hooks to access socket without causing re-renders.
  </action>
  <verify>
1. Run `npm install` in client directory successfully
2. Start both server and client: `npm run dev`
3. Open browser console - see "WebSocket connected" log
4. Check server console - see "Client connected: [socket-id]"
5. Stop server - client console shows "WebSocket disconnected"
6. Restart server - client auto-reconnects within seconds
  </verify>
  <done>
- socket.io-client package in client/package.json dependencies
- AppContext initializes socket connection on mount
- Connection status tracked in state (connected/disconnected/error)
- Socket stored in ref for access by other hooks
- Connection/disconnection handlers log to console
- Cleanup function disconnects socket on unmount
- connectionStatus exported in context value
  </done>
</task>

<task type="auto">
  <name>Implement real-time task update listeners</name>
  <files>
    client/src/context/AppContext.jsx
  </files>
  <action>
1. In AppContext.jsx, add socket event listeners after connection established:
   ```javascript
   useEffect(() => {
     const socket = socketRef.current;
     if (!socket) return;

     // Listen for task created
     socket.on('task:created', (data) => {
       console.log('Task created via WebSocket:', data.task);
       setTasks(prevTasks => [...prevTasks, data.task]);
     });

     // Listen for task updated
     socket.on('task:updated', (data) => {
       console.log('Task updated via WebSocket:', data.task);
       setTasks(prevTasks =>
         prevTasks.map(task =>
           task.id === data.task.id ? data.task : task
         )
       );
     });

     // Listen for task deleted
     socket.on('task:deleted', (data) => {
       console.log('Task deleted via WebSocket:', data.task);
       setTasks(prevTasks =>
         prevTasks.filter(task => task.id !== data.task.id)
       );
     });

     return () => {
       socket.off('task:created');
       socket.off('task:updated');
       socket.off('task:deleted');
     };
   }, []);
   ```

2. Important: Use functional state updates (prevTasks =>) to avoid stale closure issues
3. Clean up listeners on unmount to prevent memory leaks
4. Keep existing fetchTasks, addTask, updateTask, deleteTask methods unchanged - they still work via HTTP but now WebSocket provides instant updates to ALL clients

Why this approach: Functional state updates ensure we always work with latest state even if events arrive rapidly. Event handlers merge WebSocket updates with existing local state. HTTP methods still work for mutations, WebSocket handles broadcasting to other clients.
  </action>
  <verify>
1. Open manager interface in two browser tabs side by side
2. In Tab 1, create a new task via UI
3. Tab 2 immediately shows the new task (within 1 second, no refresh)
4. In Tab 2, edit task status
5. Tab 1 immediately reflects the change
6. Open TaskConfirmationPage in third tab, mark task complete
7. Both manager tabs update immediately showing task completed
8. Check console logs show "Task updated via WebSocket" messages
  </verify>
  <done>
- Socket event listeners added for 'task:created', 'task:updated', 'task:deleted'
- Functional state updates used to modify tasks array
- Cleanup functions remove event listeners on unmount
- Console logs show WebSocket events being received
- Multiple tabs display synchronized data in real-time
- No manual refresh needed to see updates from other clients
  </done>
</task>

<task type="auto">
  <name>Add connection status indicator to UI</name>
  <files>
    client/src/components/layout/Sidebar.jsx
  </files>
  <action>
1. In Sidebar.jsx:
   - Import useApp hook to access connectionStatus
   - Add connection status indicator at top or bottom of sidebar:
     ```javascript
     const { connectionStatus } = useApp();

     const getStatusColor = () => {
       switch (connectionStatus) {
         case 'connected': return 'bg-green-500';
         case 'disconnected': return 'bg-red-500';
         case 'error': return 'bg-yellow-500';
         default: return 'bg-gray-500';
       }
     };

     const getStatusText = () => {
       switch (connectionStatus) {
         case 'connected': return 'מחובר';
         case 'disconnected': return 'מנותק';
         case 'error': return 'שגיאה';
         default: return 'לא ידוע';
       }
     };
     ```

2. Add visual indicator (small badge with dot and text) in Sidebar component:
   - Position at bottom of sidebar above DataControls button area
   - Use Tailwind classes for styling: small dot with status color + Hebrew text
   - Keep minimal and non-intrusive (user should notice if disconnected, but not be distracted when connected)

3. Styling suggestion (Claude's discretion):
   ```jsx
   <div className="mt-auto px-4 py-3 border-t border-gray-200">
     <div className="flex items-center gap-2 text-sm">
       <div className={`w-2 h-2 rounded-full ${getStatusColor()} ${connectionStatus === 'connected' ? 'animate-pulse' : ''}`}></div>
       <span className="text-gray-600">{getStatusText()}</span>
     </div>
   </div>
   ```

Why this approach: Small, subtle indicator that shows connection health. User can quickly see if real-time updates are working. Placed in Sidebar since it's always visible. Hebrew text for consistency with rest of UI.
  </action>
  <verify>
1. Start app, see connection indicator in sidebar showing "מחובר" with green dot
2. Stop server, indicator changes to "מנותק" with red dot within seconds
3. Restart server, indicator returns to "מחובר" automatically
4. Indicator doesn't obstruct other UI elements
5. Visual design matches rest of application style
  </verify>
  <done>
- Sidebar imports and uses connectionStatus from AppContext
- Connection status indicator displayed in Sidebar
- Color coding: green (connected), red (disconnected), yellow (error)
- Hebrew text labels for status
- Positioned appropriately in Sidebar (bottom or top)
- Subtle animation or styling for connected state (optional)
- Indicator visible but not distracting
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete real-time infrastructure: WebSocket server broadcasting task updates, React client receiving and displaying updates instantly, connection status indicator visible to user.
  </what-built>
  <how-to-verify>
1. Start the application with `npm run dev` (both server and client running)

2. Open manager interface in TWO browser tabs side by side (e.g., http://localhost:5173 in two tabs)

3. Verify connection status:
   - Both tabs show "מחובר" (connected) indicator with green dot in sidebar
   - If not connected, wait 5 seconds for auto-connection

4. Test Task Creation real-time update:
   - In Tab 1: Click floating "הוסף משימה" button, create a new task (any details)
   - Expected: Tab 2 immediately shows the new task (within 1 second, no manual refresh)

5. Test Task Update real-time update:
   - In Tab 2: Click on the newly created task, change its status or edit details, save
   - Expected: Tab 1 immediately reflects the change

6. Test Task Completion from confirmation page:
   - In manager interface, send a task to an employee (this creates confirmation link)
   - Open the confirmation link in a THIRD tab (the `/confirm/:token` page)
   - Mark the task as complete by checking the checkbox
   - Expected: Both manager tabs (Tab 1 and Tab 2) immediately show task status changed to "completed"

7. Test Connection Stability:
   - Leave both manager tabs open for 2-3 minutes without interaction
   - Create another task in Tab 1
   - Expected: Tab 2 still receives the update (connection didn't timeout)

8. Test Connection Loss/Recovery:
   - Stop the server (Ctrl+C in server terminal)
   - Expected: Both tabs show "מנותק" (disconnected) with red dot
   - Restart server with `npm run dev:server`
   - Expected: Both tabs auto-reconnect and show "מחובר" within 5-10 seconds

9. Visual check:
   - Connection indicator is visible and not obstructing other UI
   - Indicator style matches application design (colors, fonts, spacing)
   - All existing functionality still works (creating, editing, deleting tasks)

**Success signals:**
- ✓ Updates appear in all tabs within 1 second
- ✓ No page refresh needed to see changes
- ✓ Connection indicator accurately reflects connection state
- ✓ Connection survives idle periods (at least 2-3 minutes)
- ✓ Auto-reconnect works after server restart

**Failure signals:**
- ✗ Updates require manual page refresh
- ✗ Connection indicator stuck on "מנותק"
- ✗ Console errors about WebSocket or Socket.IO
- ✗ Some tabs receive updates, others don't
- ✗ Connection drops after being idle
  </how-to-verify>
  <resume-signal>
Type "approved" if all verification checks pass, or describe any issues observed.
  </resume-signal>
</task>

</tasks>

<verification>
After completing all tasks and human verification:

1. Real-time updates work across multiple browser tabs
2. Task mutations (create/update/delete) broadcast via WebSocket
3. Connection status indicator displays correct state
4. Connection remains stable during normal usage (survives idle time)
5. Auto-reconnect works after temporary disconnection
6. All four Phase 1 requirements satisfied:
   - RT-01: WebSocket connection established
   - RT-02: Manager sees task completion immediately
   - RT-03: Manager sees image uploads immediately (foundation ready)
   - RT-04: Manager sees notes immediately (foundation ready)
</verification>

<success_criteria>
- Manager opens interface, sees "מחובר" status
- Worker marks task complete in confirmation page, manager sees update within 1 second without refresh
- Connection stays stable for at least 1 hour
- Multiple browser tabs all receive and display updates simultaneously
- All Success Criteria from Phase 1 roadmap satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-real-time-infrastructure/01-02-SUMMARY.md`
</output>
