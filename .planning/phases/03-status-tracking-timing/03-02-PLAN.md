---
phase: 03-status-tracking-timing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - server/routes/tasks.js
autonomous: true

must_haves:
  truths:
    - "Tasks returned by API include late detection flag (is_late)"
    - "Tasks include timing status (on-time, near-deadline, late)"
    - "Completed tasks include time delta text (early/on-time/late)"
    - "Late detection only applies to non-completed tasks past estimated end time"
  artifacts:
    - path: "server/routes/tasks.js"
      provides: "Dynamic late detection and timing enrichment"
      exports: ["enrichTaskWithTiming"]
    - path: "server/routes/tasks.js"
      provides: "Time delta calculation for completed tasks"
      exports: ["calculateTimeDelta"]
  key_links:
    - from: "GET /api/tasks/today"
      to: "enrichTaskWithTiming"
      via: "Enriches each task before sending to client"
      pattern: "tasks\\.map\\(enrichTaskWithTiming\\)"
    - from: "enrichTaskWithTiming"
      to: "date-fns differenceInMinutes"
      via: "Calculates time remaining/overdue"
      pattern: "differenceInMinutes\\("
---

<objective>
Add dynamic late detection and timing status calculation to backend API responses.

Purpose: Enrich task objects with timing information (is_late, minutes_remaining, timing_status, time_delta) so frontend can display accurate late indicators without client-side time calculations.

Output: All task API endpoints return enriched task objects with late detection flags, time remaining/overdue, and completion variance calculations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-status-tracking-timing/03-RESEARCH.md

# This plan builds on Plan 01
@.planning/phases/03-status-tracking-timing/03-01-PLAN.md

# Key file to modify
@server/routes/tasks.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add enrichTaskWithTiming function with late detection</name>
  <files>server/routes/tasks.js</files>
  <action>
    Add enrichTaskWithTiming function after calculateEstimatedEnd (created in Plan 01):

    ```javascript
    /**
     * Enrich task with timing information (late detection, time remaining, etc.)
     * @param {Object} task - Task object from database
     * @returns {Object} Task with added timing fields
     */
    function enrichTaskWithTiming(task) {
      // Skip timing logic for completed tasks (calculate delta instead)
      if (task.status === 'completed') {
        return {
          ...task,
          ...calculateTimeDelta(task)
        };
      }

      const now = new Date();
      const estimatedEnd = calculateEstimatedEnd(task);
      const minutesRemaining = differenceInMinutes(estimatedEnd, now);

      const isLate = minutesRemaining < 0;
      const isNearDeadline = !isLate && minutesRemaining < 10;

      return {
        ...task,
        estimated_end_time: estimatedEnd.toTimeString().slice(0, 5), // "HH:MM"
        is_late: isLate,
        minutes_remaining: Math.abs(minutesRemaining), // Always positive for display
        timing_status: isLate ? 'late' : (isNearDeadline ? 'near-deadline' : 'on-time')
      };
    }
    ```

    Import differenceInMinutes from date-fns at the top (addMinutes already imported):
    ```javascript
    const { addDays, addWeeks, addMonths, format, differenceInMinutes } = require('date-fns');
    ```

    This calculates late status dynamically on every request, ensuring always-accurate timing without stored status fields (per RESEARCH.md anti-patterns).
  </action>
  <verify>
    1. enrichTaskWithTiming function exists in tasks.js
    2. differenceInMinutes imported from date-fns
    3. Function returns task with new fields: estimated_end_time, is_late, minutes_remaining, timing_status
    4. Server starts without errors
  </verify>
  <done>
    Backend dynamically calculates late status, time remaining, and timing status for all non-completed tasks on every API call.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add calculateTimeDelta function for completed tasks</name>
  <files>server/routes/tasks.js</files>
  <action>
    Add calculateTimeDelta function after enrichTaskWithTiming:

    ```javascript
    /**
     * Calculate time delta for completed tasks (early/on-time/late)
     * @param {Object} task - Completed task with completed_at timestamp
     * @returns {Object} Object with delta fields
     */
    function calculateTimeDelta(task) {
      if (!task.completed_at) {
        return {
          time_delta_minutes: null,
          time_delta_text: null
        };
      }

      const estimatedEnd = calculateEstimatedEnd(task);
      const actualEnd = new Date(task.completed_at);
      const deltaMinutes = differenceInMinutes(actualEnd, estimatedEnd);

      let deltaText;
      if (deltaMinutes < 0) {
        deltaText = `הושלם מוקדם ב-${Math.abs(deltaMinutes)} דקות`;
      } else if (deltaMinutes > 0) {
        deltaText = `איחור של ${deltaMinutes} דקות`;
      } else {
        deltaText = 'הושלם בזמן';
      }

      return {
        time_delta_minutes: deltaMinutes,
        time_delta_text: deltaText
      };
    }
    ```

    This provides Hebrew text for displaying completion variance (early/on-time/late) in manager UI.
  </action>
  <verify>
    1. calculateTimeDelta function exists in tasks.js
    2. Returns null values if completed_at is missing
    3. Returns positive deltaMinutes for late, negative for early, 0 for on-time
    4. Returns Hebrew text appropriate for display
    5. Server starts without errors
  </verify>
  <done>
    Backend calculates completion time variance (actual vs estimated) with Hebrew display text for completed tasks.
  </done>
</task>

<task type="auto">
  <name>Task 3: Apply enrichment to all task API endpoints</name>
  <files>server/routes/tasks.js</files>
  <action>
    Modify task retrieval endpoints to enrich tasks before sending to client:

    1. **GET /api/tasks/today** (around line 34-50):
       Before `res.json(tasks);`, map through enrichment:
       ```javascript
       const enrichedTasks = tasks.map(enrichTaskWithTiming);
       res.json(enrichedTasks);
       ```

    2. **GET /api/tasks/:id** (around line 182-200):
       Before `res.json(task);`, enrich single task:
       ```javascript
       const enrichedTask = enrichTaskWithTiming(task);
       res.json(enrichedTask);
       ```

    3. **GET /api/tasks/:id/attachments** endpoint:
       DO NOT modify - this returns attachments array, not task objects

    4. **POST /api/tasks/:id/approve** (around line 54-158):
       After getting updatedTask (line ~137-143), enrich before response AND Socket.IO broadcast:
       ```javascript
       const enrichedTask = enrichTaskWithTiming(updatedTask);

       // Broadcast enriched task
       if (io) {
         io.emit('task:updated', { task: enrichedTask });
       }

       res.json({
         success: true,
         message: 'המשימה אושרה בהצלחה',
         task: enrichedTask
       });
       ```

    5. **POST /** (create task, around line 222-372):
       Enrich newTask before broadcasting (line ~361):
       ```javascript
       const enrichedTask = enrichTaskWithTiming(newTask);
       if (io) {
         io.emit('task:created', { task: enrichedTask });
       }
       res.status(201).json(enrichedTask);
       ```

    6. **PUT /:id** (update task, around line 374-408):
       Enrich updatedTask before broadcasting (line ~397):
       ```javascript
       const enrichedTask = enrichTaskWithTiming(updatedTask);
       if (io) {
         io.emit('task:updated', { task: enrichedTask });
       }
       res.json(enrichedTask);
       ```

    7. **PUT /:id/status** (around line 410-521):
       Enrich updatedTask before broadcasting (line ~510):
       ```javascript
       const enrichedTask = enrichTaskWithTiming(updatedTask);
       if (io) {
         io.emit('task:updated', { task: enrichedTask });
       }
       res.json(enrichedTask);
       ```

    8. **GET /** (all tasks, around line 17-30):
       Enrich before sending:
       ```javascript
       const enrichedTasks = tasks.map(enrichTaskWithTiming);
       res.json(enrichedTasks);
       ```

    This ensures all task objects sent to client include timing information, and all Socket.IO broadcasts include enriched data for real-time updates.

    IMPORTANT: Do NOT modify the task object before database operations - enrichment is ONLY for API responses. Database stores source data (start_time, estimated_duration_minutes, completed_at), enrichment calculates derived data (is_late, timing_status, etc.).
  </action>
  <verify>
    1. All 8 endpoints identified are modified
    2. Enrichment happens AFTER database queries, BEFORE responses/broadcasts
    3. Socket.IO broadcasts send enriched tasks (with timing data)
    4. Server starts without errors
    5. Test GET /api/tasks/today - response should include is_late, minutes_remaining, timing_status fields
  </verify>
  <done>
    All task API endpoints return enriched task objects with timing information. Real-time Socket.IO broadcasts include timing data for immediate UI updates.
  </done>
</task>

</tasks>

<verification>
1. enrichTaskWithTiming and calculateTimeDelta functions exist in tasks.js
2. All task retrieval endpoints apply enrichment before sending responses
3. Socket.IO broadcasts include enriched task objects
4. Server starts without errors
5. Test API responses include new fields: is_late, minutes_remaining, timing_status, estimated_end_time
6. Completed tasks include time_delta_minutes and time_delta_text
7. Existing functionality unaffected (tasks still create, update, delete normally)
</verification>

<success_criteria>
1. Backend dynamically calculates late status on every API call (no stored late flag)
2. Tasks past estimated end time are marked is_late: true
3. Tasks within 10 minutes of deadline are marked timing_status: 'near-deadline'
4. Completed tasks show time variance (early/on-time/late) in Hebrew
5. All API responses and Socket.IO events include timing data
6. Foundation ready for Plan 03 to display timing information in UI
7. Requirements satisfied: TS-03 (status logic), TS-04 (auto-late detection), TS-07 (time variance calculation)
</success_criteria>

<output>
After completion, create `.planning/phases/03-status-tracking-timing/03-02-SUMMARY.md` documenting:
- Enrichment functions implemented
- All endpoints modified
- Real-time broadcast timing data
- Any deviations from plan
- Requirements satisfied: TS-03, TS-04, TS-07
</output>
